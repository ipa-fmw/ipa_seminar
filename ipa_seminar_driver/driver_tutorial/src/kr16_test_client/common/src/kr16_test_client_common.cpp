//ROS typedefs
#include "ros/ros.h"
#include <control_msgs/JointTrajectoryControllerState.h>

/* protected region user include files on begin */
#include <actionlib/client/simple_action_client.h>
#include <control_msgs/FollowJointTrajectoryAction.h>
/* protected region user include files end */

class kr16_test_client_config
{
public:
	std::string joint_position_1;
	std::string joint_position_2;

};

class kr16_test_client_data
{
	// autogenerated: don't touch this class
public:
	//input data
	control_msgs::JointTrajectoryControllerState in_state;


	//output data


};

class kr16_test_client_impl
{
	/* protected region user member variables on begin */

	/* protected region user member variables end */

public:
	kr16_test_client_impl()
	{
		/* protected region user constructor on begin */

		/* protected region user constructor end */
	}
	void configure(kr16_test_client_config config)
	{
		/* protected region user configure on begin */
		/* protected region user configure end */
	}
	void update(kr16_test_client_data &data, kr16_test_client_config config)
	{
		/* protected region user update on begin */

		actionlib::SimpleActionClient<control_msgs::FollowJointTrajectoryAction> ac("follow_joint_trajectory_action", true);
		ROS_INFO("kr16_test_client_impl: Waiting for action server to start.");
		ac.waitForServer(); //will wait for infinite time

		// declaring goal of the action
		control_msgs::FollowJointTrajectoryGoal goal;
		// We will have two waypoints in this goal trajectory
		goal.trajectory.points.resize(2);

		int ind = 0;
		goal.trajectory.points[ind].positions.resize(7);
		goal.trajectory.points[ind].positions[0] = -35;
		goal.trajectory.points[ind].positions[1] = -98;
		goal.trajectory.points[ind].positions[2] = 108;
		goal.trajectory.points[ind].positions[3] = -0.2;
		goal.trajectory.points[ind].positions[4] = 80;
		goal.trajectory.points[ind].positions[5] = 0.4;
		goal.trajectory.points[ind].positions[6] = 0.0;
		// Velocities
		goal.trajectory.points[ind].velocities.resize(7);
		for (size_t j = 0; j < 7; ++j)
		{
			goal.trajectory.points[ind].velocities[j] = 10.0;
		}
		// To be reached 1 second after starting along the trajectory
		goal.trajectory.points[ind].time_from_start = ros::Duration(60.0);

		// Second trajectory point
		// Positions
		ind += 1;
		goal.trajectory.points[ind].positions.resize(7);
		goal.trajectory.points[ind].positions[0] = -25;
		goal.trajectory.points[ind].positions[1] = -95;
		goal.trajectory.points[ind].positions[2] = 105;
		goal.trajectory.points[ind].positions[3] = -0.5;
		goal.trajectory.points[ind].positions[4] = 80;
		goal.trajectory.points[ind].positions[5] = 10.5;
		goal.trajectory.points[ind].positions[6] = 0;
		// Velocities
		goal.trajectory.points[ind].velocities.resize(7);
		for (size_t j = 0; j < 7; ++j)
		{
			goal.trajectory.points[ind].velocities[j] = 10.0;
		}
		// To be reached 2 seconds after starting along the trajectory
		goal.trajectory.points[ind].time_from_start = ros::Duration(60.0);


		// ********************************//
		// sending of goal to actionserver //
		// ********************************//

		// send the goal to the action server
		ac.sendGoal(goal);
		ROS_INFO("kr16_test_client_impl: Sending trajectory to server");

		// ********************************//
		// waiting for reply by act-server //
		// ********************************//

		// wait for the action to return
		ROS_INFO("kr16_test_client_impl: Waiting for action to return");
		bool finished_before_timeout = ac.waitForResult(ros::Duration(60.0));

		// handling possible timeout of actionserver reply
		if (finished_before_timeout)
		{
			actionlib::SimpleClientGoalState state = ac.getState();
			ROS_WARN("kr16_test_client_impl: Action finished: %s",state.toString().c_str());
		}
		else
		{
			ROS_WARN("kr16_test_client_impl: Action did not finish before the time out.");
		}
		/* protected region user update end */

	}



	/* protected region user additional functions on begin */
	/* protected region user additional functions end */

};
