//ROS typedefs
#include "ros/ros.h"
#include <sensor_msgs/JointState.h>
#include <control_msgs/JointTrajectoryControllerState.h>

/* protected region user include files on begin */
//driver
#include <KukaEthernetClient/KukaEthernetClient.h>
#include <queue>
/* protected region user include files end */

class kr16_node_config
{
public:
	std::string robot_ip_address;
	std::string robot_description;
	int robot_port;

};

class kr16_node_data
{
	// autogenerated: don't touch this class
public:
	//input data


	//output data
	sensor_msgs::JointState out_joint_states;
	control_msgs::JointTrajectoryControllerState out_state;


};

class kr16_node_impl
{
	/* protected region user member variables on begin */
	KukaEthernetClient kuka_client_;
	bool kuka_callback_received_;
	int polling_rate_;
	int received_msg_id_;
	sensor_msgs::JointState joint_state_msg_;
	std::vector<std::string> joint_names_;
	/* protected region user member variables end */

public:
	kr16_node_impl()
	{
		/* protected region user constructor on begin */
		// Kuka Communication specifics
		polling_rate_ = 100;
		kuka_callback_received_ = false;
		received_msg_id_ = -1;
		/* protected region user constructor end */
	}
	void configure(kr16_node_config config)
	{
		/* protected region user configure on begin */
		bool dummy_mode = false;
		bool auto_connect = true;
		std::string xml_path = "/home/ros/catkin_ws/src/ipa325_kr16/ipa325_EkiDriver/common/files/EKIServerFrame.xml";
		kuka_client_.setClientDummy(dummy_mode);

		ROS_INFO("kr16_node_impl: Initializing KRC Ethernet Client");

		if (!kuka_client_.Initialize(xml_path, SocketAddress(config.robot_ip_address, config.robot_port), auto_connect))
		{
			int error = kuka_client_.getError();
			if ( error == 1)
			{
				ROS_ERROR("kr16_node_impl: Connection to KUKA KRC failed");
			}
			else if (error == 2)
			{
				ROS_ERROR("kr16_node_impl: Xml KRC definition file could not be parsed");
			}
			else if (error == 3)
			{
				ROS_ERROR("kr16_node_impl: Connection failed AND Xml KRC definition file could not be parsed");
			}
		}
		else
		{
			ROS_INFO("kr16_node_impl: Successfully connected to KUKA KRC");
		}

		boost::function<void (int)> fct( boost::bind( &kr16_node_impl::kukaCallback, this, _1 ) );
		kuka_client_.setCallbackFcn(fct);
		/* protected region user configure end */
	}
	void update(kr16_node_data &data, kr16_node_config config)
	{
		/* protected region user update on begin */
		data.out_joint_states = joint_state_msg_;
		/* protected region user update end */
	}


	void callback_follow_joint_trajectory_action_(const control_msgs::FollowJointTrajectoryGoalConstPtr &goal, actionlib::SimpleActionServer<control_msgs::FollowJointTrajectoryAction> *as_)
	{
		/* protected region user implementation of action callback for follow_joint_trajectory_action on begin */
		// helper variables
		ros::Rate r(polling_rate_);
		kuka_callback_received_ = false;

		std::queue<int> msg_queue;

		// TODO: Publish the feedback

		ROS_INFO("kr16_node_impl: FollowjointTrajectoryGoal received containing %i waypoints.", goal->trajectory.points.size()) ;

		for (u_int i = 0; i < goal->trajectory.points.size(); i++)
		{
			if (goal->trajectory.points[i].velocities.size() > 1)
			{
				ROS_WARN("kr16_node_impl: Only first velocity is accepted and defines all axes!");
			}
			float overall_velocity = goal->trajectory.points[i].velocities[0];

			int current_msg_id = kuka_client_.getMessageID();
			msg_queue.push(current_msg_id);

			kuka_client_.movePTP(current_msg_id,
					goal->trajectory.points[i].positions[0],
					goal->trajectory.points[i].positions[1],
					goal->trajectory.points[i].positions[2],
					goal->trajectory.points[i].positions[3],
					goal->trajectory.points[i].positions[4],
					goal->trajectory.points[i].positions[5],
					overall_velocity);
		}

		// waiti until execution of the action has finished
		while (!msg_queue.empty() && ros::ok() && !as_->isPreemptRequested())
		{
			if(kuka_callback_received_)
			{
				kuka_callback_received_ = false;
				// work through msgId-Queue;
				if(msg_queue.front() != received_msg_id_)
				{
					ROS_WARN("kr16_node_impl: QueueFront = %i; Recv = %i -> Indicating sync problem! Send Actions does not match responses by KRC", msg_queue.front(), received_msg_id_);
				}
				msg_queue.pop();
			}

			// TODO: publish the feedback
			//as_->publishFeedback(trajfeedback_);
			r.sleep();
		}

		if (as_->isPreemptRequested() || !ros::ok())
		{
			ROS_INFO("kr16_node_impl: : Preempted");
			// set the action state to preempted
			as_->setPreempted();
		}
		else
		{
			ROS_INFO("kr16_node_impl: : Succeeded");
			// set the action state to succeeded
			as_->setSucceeded();
		}
		/* protected region user implementation of action callback for follow_joint_trajectory_action end */

	}




	/* protected region user additional functions on begin */
	void kukaCallback(int msgID)
	{
		ROS_INFO("kr16_node_impl: KRC called back with MsgID %i done", msgID);

		received_msg_id_ = msgID;

		kuka_callback_received_ = true;
		ROS_INFO("kr16_node_impl: Kuka callback received");

		KukaAxis current_axis = kuka_client_.getCurrentAxis();

		//Setting joint state
		sensor_msgs::JointState joint_state_msg;
		joint_state_msg.header.stamp = ros::Time::now();
		joint_state_msg.name = joint_names_;
		joint_state_msg.position = current_axis.toStdVector();

		//robot_pose = kuka_client_.getCurrentFrame();
	}
	/* protected region user additional functions end */

};
